################################
AUTHENTICATION OPTIONS FOR API'S
################################
I.	SESSIONS VS TOKENS
II.	STATELESS VS STATEFULL JWT
III.	ADDITIONAL MEASURES
################################

EXPRESS SETUP: SESSIONS + PASSPORT

- CUSTOM SOLUTIONS: JWT + Local Storage
- PROVIDER API'S: Auth0, Firebase, OAuth2.0 (Open Standard)


#######################
I.	SESSION VS TOKENS
#######################

SESSIONS are battle-tested for 20+ years and are not open to XSS attacks if cookies used the correct flags (http-only). They also do no contain any meaningful data that can be exploited.

Downside are:
- session auth needs to be secured against CSRF attacks
- all active sessions need to be stored on a server or cache manager which present scalability challenges
- possible single point of failure if all session are managed by a single server.
- sharing the data over multiple servers is challenging: see STICKY SESSION with load-balancing (horizontal scaling and Cross Origin Resources Sharing).
- cookies need to be enabled


JSON WEB TOKENS
When apps use various servers on the back-end to seperate their data, for example, a bank with a server for bank info and another server for retirement accounts, a user should be able to navigate through various sections with the same login session (CORS: cross origin resource sharing).

With JWT the user-info is stored on the client-side(browser) and if the same serialization key is used for both servers, the same token can be verified by both servers.

Since JWT work accross different servers you can move the entire authorization process to a seperate server and thereby divide the workload. 

The server can identify a user by reading the token that is embed inside the request, thus less database lookups.

Main advantages is big enterprise scaling.

Downside:
- unless the token is encypted the user data embeded in the token is publicly available as it is only URL encoded. If the site is vulnerable to XSS cross-site-scripting attacks with JS malicious code injection, the tokens can be read and used to make malicious AJAX requests to server on behalf of the authorized user.
- the server still needs to track the active tokens somehow by blacklisting the old or expired tokens. This means that JWT actually are not entirely STATELESS. Usually the best way to handle this is with a WHITELIST of tokens, thus nobody gets access unless on the whitelist.
- data in the payload of a token can go out of sync with the server as it is chached, it goes stale.
- requires Javascript to be enabled as Client Storage is a JS API.

SESSIONS:
- session are managed on the server and sessionID links to user data in the database
- sessionID is signed and stored in cookie, sent to client via Set-Cookie in the header, with or without flags to be scoped within the same domain
- additional CSFR cookie can be issued

WHY NOT JWT FOR WEBAPPS?
- server state needs to be maintained either way
- session are easily extended or invalidated
- data is secured server side and cannot leak through XSS (as http-only cookies are not accessible for JS)
- CSFR attacks are easier to mitigate
- user data is always in sync with the database

###############################
II.	STATELESS VS STATEFUL JWT
###############################

STATELESS JWT: the traditional way

- User payload is embeded in the token
- token is signed by the server and base64-url encoded
- send via Authorization header
- stored in unsecure plaintext LocalStorage
- server retrieves userinfo from the token
- refresh tokens are sent with the initial access token
- expired or revoked tokens are maintained in a blacklist

STATEFUL JWT

- only a user reference is stored in the payload (as an ID)
- token is signed by the server and base64-url encoded
- sent via header as a HTTP-ONLY FLAGGED COOKIE (not accessible by js code) along-side a non-http X-CSFR-TOKEN COOKIE (accessible by js, read by the client and send along each new user request)
- server uses the userID in the TOKEN to retrieve the full user data from a DB
- no user sessions stored on the server
- revoked tokens need to persist on blacklist


#########################
III.	ADDITIONAL MEASURES
#########################

XSS always remains a concern:
- security headers must be set
- ssl/https is important

Auxiliary measures
- ip verification
- user agent verification
- two factor auth
- API throttling