#################
ODM WITH MONGOOSE
################################################
I.	ABOUT ODM
II.	SETUP
III.	SCHEMA AND MODEL
IV.	SAVING TO DATABASE
V.	RETRIEVE DATA
	A.	PASSING RETRIEVED DATA TO VIEW PAGES
	B.	FINDING ROUTE PARAMETER
################################################

###############
I.	ABOUT ODM
###############

Mongoose is an Object Document Modeling (ODM) package which facilitates the database operations between the server package EXPRESS and the MONGODB databse. It is a JS layer on top of MongoDB.

You setup the connection in the EXPRESS app.js file and from then on the running app.js can CRUD on the database.

You can make this connections without a ODM package but that takes more code to write yourself.

######################
II.	SETUP IN EXPRESS
######################

In the app.js add following code. Note that if the db is not found, it will be created. 

	mongoose.connect(process.env.DB_CONN, 
		{useNewUrlParser: true});
	db.on('error', console.error.bind(console, '\nConnection 	error:\n'));
	db.once('open', () => {
    		console.log('\nDatabase connection established');
	});	

process.env.DB_CONN='mongodb://localhost/<db-name>',

Use an if to check for the presence of an ENV URI. If none is set, use the local db or the database that is used in development. 

By using this approach the code is setup for deployment, no matter what the location of the production server may be.

Use: process.env.Mongo.DB.URI

To activate the DEBUG MODE:
	mongoose.set({'debug': true})

To use the PROMISES syntax:
	mongoose.Promise = Promise;

NOTE about code organization:

Use a MODELS folder and inside use and index.js file connect to the DB, and other <name>Schema.js files to create the actual models.

Inside each file you have to REQUIRE in MONGOOSE.

######################	 
III.	SCHEMA AND MODEL
######################

The SCHEMA is the structure of your DOCUMENT OBJECTS and the MODEL is a class with which we construct documents.

	let <ModelName> = momgoose.model('ModelName', SchemaName);

NOTE: the 'ModelName' will be used as the name of the collection, pluralized. Thus 'Dog' becomes a collection DOGS 

	let <name>Schema = new mongoose.Schema({
		name: <dataType>
		location: String
		age: Number
	})

The ModelName can now be used with it's methods, just as in the database itself:

	<ModelName>.find()
	<ModelName>.create()
	<ModelName>.delete()
	etc.

################################### 
IV.	SAVING/CREATE TO THE DATABASE
###################################

SAVE

Each document can be saved to the database by calling its save method. Though in practice you will be using the CREATE route.

	let testDocument = new ModelName({
		name: 'adas', age: '24', location: 'eaeaf'
	});

	testDocument.save((err, savedData) => {
    		if (err) {return console.error(err);}
		else {return console.log('Saved succesfully: '), 				savedData}

	// The callback function is necessary to confirm 

CREATE

	ModelName.create({newObject}, cbFn)
	
The newObject data will be retrieved from a input elemenent in a form with a NAME attribute. Those name attributes form part of the POST request and can be found in the body:

	let newDataA = req.body.<nameAttributeA>
	let newDataB = req.body.<nameAttributeB>
	
Store the new-to-create-object:
	
	let newObject = {<name>: newDataA, <name>: newDataB}

The callback function has two parameters: the error and the dataObject that is being stored in the database. You can name it as you please.

If the data is created succesfully you can specify actions, for example: 
	- send the user back to the original page
	- console.log
	- show feedback to user on the same page, etc.

	(err, savedData) => {
		if(err){console.log(err)}
			else {
			console.log('Succesfully added to DB:\n', 						newDataEntry);
			res.redirect('/');
			OTHER...
		}
	}

##########################################
V.	READ/RETRIEVE DATA FROM THE DATABASE
##########################################

You can display all or partial database data on the pages of your site. usually within an app.get() request.

	ModelName.find({dataToShow}, cb)

The dataToShow can be: find({}), that is all entries or documents in the collection. Or only those with a specific name:
	
	ModelName.find({name: 'example'}, cb)

IMPORTANT! The callback function has same double function as above: error reporting and ACTIONS to take upon succesfull retrieval of data from the db. The retrieved data will be an object that we call 'foundData'

	(err, foundData) => {
		if(err){console.log(err)}
			else {
				res.render('page', {key: founData})
			}
	}

In the views/page.ejs you can now access the data object and use it's properties:
	
	<h1><%= key.name %></h1> 
	<p><%= key.description %></p>
 
B.	RETRIEVING DATA USING THE SHOW ROUTE WITH ROUTE PARAMETER

Each document in the collection has a unique ID. You can send the users to a route with this ID by accessing it in the HTML when creating a link:

	href="/page/<%= dataObject.id %>"

For this to work you need setup an ID GET ROUTE in the EXPRESS app with A ROUTE PARAMETER:

	app.get('/page/:id', (req, res){})

To use the ID to find a SPECIFIC document in the DB and display it on the page MONGOOSE has a METHOD called findById(). 

To know which ID to look for in the DB you look inside the GET REQUEST PARAMETERS and pass is to the findById() method:
	
	app.get('/page/:id', (req, res)=>{
		ModelName.findById(req.params.id, (err, founData) => {
			res.render('id-page', {dataObject: founData})
		})		
	})

Final step on the ID-PAGE is access the dataObject and display the properties you want:

	<h1><%= dataObject.name %>
	<p><%= dataObject.description %>
